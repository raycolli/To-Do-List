# -*- coding: utf-8 -*-
"""UHTour.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SJBB4OIUjrpNk3TT563NwHccBAmJQ3mL
"""

pip install ortools

pip install googlemaps

from scipy.spatial.distance import euclidean
from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp
from scipy.spatial.distance import euclidean
from itertools import permutations
import matplotlib.pyplot as plt
import numpy as np

from geopy.distance import geodesic
from getpass import getpass

from math import radians, sin, cos, sqrt, atan2

# List of UH buildings
# 40 buildings
#  {"name": "", "locations": ()}

buildings = [
    {"name": "Science & Engineering Classroom Building (SEC 105)", "locations": (29.7237384, -95.3453009)},
    {"name": "Science and Research 1", "locations": (29.7226705, -95.3450538)},
    {"name": "Science and Research 2", "locations": (29.72374, -95.3450258)},
    {"name": "Agnes Arnold Auditorium", "locations": (29.722485, -95.3439333)},
    {"name": "Agnes Arnold Hall", "locations": (29.7221257, -95.3440745)},
    {"name": "Graduate College of Social Work", "locations": (29.7227346, -95.3438379)},
    {"name": "Philip Guthrie Hoffman Hall", "locations": (29.7215626, -95.3436278)},
    {"name": "Technology Annex", "locations": (29.7225764, -95.3431086)},
    {"name": "College of Technology", "locations": (29.7233165, -95.3426471)},
    {"name": "Science Building", "locations": (29.721472, -95.3444812)},
    {"name": "Lamar Fleming", "locations": (29.7216126, -95.3457797)},
    {"name": "Science Teaching Laboratory Building", "locations": (29.7217413, -95.3465766)},
    {"name": "Charles F. McElhinney Hall", "locations": (29.7211884, -95.3463007)},
    {"name": "Fred J. Heyne", "locations": (29.7205173, -95.3461482)},
    {"name": "Roy G. Cullen", "locations": (29.720123, -95.3447752)},
    {"name": "Ezekiel W. Cullen", "locations": (29.7204262, -95.3438134)},
    {"name": "Stephen Power Farish Hall", "locations": (29.7209729, -95.3450941)},
    {"name": "M.D Anderson Library", "locations": (29.7210345, -95.3426496)},
    {"name": "Central Power Plant", "locations": (29.7221216, -95.3420521)},
    {"name": "Sudent Center North", "locations": (29.7206588, -95.3407791)},
    {"name": "Student Center South", "locations": (29.720015, -95.3410593)},
    {"name": "Conrad N. Hilton College of Global Hospitality Leadership", "locations": (29.7193072, -95.3413211)},
    {"name": "Visitor Information Booth 1", "locations": (29.7193333, -95.3402617)},
    {"name": "Cullen College of Engineering 1", "locations": (29.7229759, -95.3416759)},
    {"name": "Cullen College of Engineering 2", "locations": (29.7233323, -95.3411237)},
    {"name": "Engineering Lecture Hall", "locations": (29.7226926, -95.3408213)},
    {"name": "Durga and Sushila Argrawal Engineering Research", "locations": (29.7222087, -95.3397947)},
    {"name": "Michael J. Cemo Hall", "locations": (29.7217541, -95.3400119)},
    {"name": "Classroom and Business Building", "locations": (29.7217344, -95.3409179)},
    {"name": "LeRoy & Lucile Melcher Hall", "locations": (29.7210647, -95.3398822)},
    {"name": "John M. O'Quinn Law Library", "locations": (29.7231958, -95.3386322)},
    {"name": "University of Houston Law Center", "locations": (29.7238762, -95.3385035)},
    {"name": "Gerald D. Hines College of Architecture and Design", "locations": (29.7242445, -95.3416015)},
    {"name": "Blaffer Art Museum", "locations": (29.7249899, -95.3422375)},
    {"name": "UH School of Art", "locations": (29.7244166, -95.3424494)},
    {"name": "Jack J. Valenti School of Communication", "locations": (29.7240351, -95.343768)},
    {"name": "Cynthia Woods Mitchell Center for the Arts", "locations": (29.724584, -95.3438086)},
    {"name": "Moores School of Music", "locations": (29.7254492, -95.3442273)},
    {"name": "Moores Opera House", "locations": (29.7254499, -95.3442279)},
    {"name": "Greenhouse", "locations": (29.7231087, -95.3448654)}

]

# Extract coordinates
x_coords = [building["locations"][1] for building in buildings]  # Longitude
y_coords = [building["locations"][0] for building in buildings]  # Latitude

# Make the scatter plot
plt.figure(figsize=(15, 15))
plt.scatter(x_coords, y_coords, marker='o', color='pink')

# Plot the points with building names
for building in buildings:
    plt.annotate(building["name"], (building["locations"][1], building["locations"][0]), xytext=(5, -5),
                 textcoords='offset points', fontsize=8, ha='right')

# Axis
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("UH Buildings")
plt.show()

# Function to calculate total distance
def total_distance(order, building_data):
    distance = 0
    for i in range(len(order) - 1):
        index1, index2 = order[i], order[i + 1]
        coord1 = building_data[index1]["locations"]
        coord2 = building_data[index2]["locations"]
        distance += euclidean(coord1, coord2)
    return distance

# Nearest Neighbor Algorithm
def nearest_neighbor_algorithm(buildings):
    min_distance = float('inf')
    optimal_order = None

    # Starting building is at the classroom :3
    start_index = next(index for index, building in enumerate(buildings) if building["name"] == "Science & Engineering Classroom Building (SEC 105)")

    for _ in range(len(buildings)):
        order = [start_index]
        remaining_indices = set(range(len(buildings))) - {start_index}

        while remaining_indices:
            current_building = order[-1]
            nearest_index = min(remaining_indices, key=lambda i: euclidean(buildings[current_building]["locations"], buildings[i]["locations"]))
            order.append(nearest_index)
            remaining_indices.remove(nearest_index)

        distance = total_distance(order, buildings)

        if distance < min_distance:
            min_distance = distance
            optimal_order = order

    return optimal_order

# Run the algorithm
optimal_order = nearest_neighbor_algorithm(buildings)
optimal_building_order = [buildings[i]["name"] for i in optimal_order]
print("Optimal Building Order:\n", "\n".join(optimal_building_order))

# Plot the optimal route
x_coords = [building["locations"][1] for building in buildings]  # Longitude
y_coords = [building["locations"][0] for building in buildings]  # Latitude

# Size of the scatter plot
plt.figure(figsize=(15, 15))
plt.scatter(x_coords, y_coords, marker='o', color='pink')

# Plot the points
for building in buildings:
    plt.annotate(building["name"], (building["locations"][1], building["locations"][0]))

route_x_coords = [buildings[i]["locations"][1] for i in optimal_order]
route_y_coords = [buildings[i]["locations"][0] for i in optimal_order]
plt.plot(route_x_coords, route_y_coords, marker='o', linestyle='-', color='blue')

# Axis
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("UH Buildings with Optimal Route:Nearest Neighbors")
plt.show()

average_walking_speed = 3.25  # in mph
# Calculate total distance and time taken
dist_km = total_distance(optimal_order, buildings)
# Convert kilometers to miles
dist_miles = dist_km * 0.621371
time_hours = dist_miles / average_walking_speed
time_minutes = time_hours * 60

print(f"Total Distance: {dist_km:.4f} kilometers")
print(f"Total Distance: {dist_miles:.4f} miles")
print(f"Total time: {time_minutes:.4f} minutes")

import random
import math
random.seed(42)

def euclidean(coord1, coord2):
    return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)

def total_distance(order, building_data):
    distance = 0
    for i in range(len(order) - 1):
        index1, index2 = order[i], order[i + 1]
        coord1 = building_data[index1]["locations"]
        coord2 = building_data[index2]["locations"]
        distance += euclidean(coord1, coord2)
    return distance

def simulated_annealing(buildings):
    start_building = "Science & Engineering Classroom Building (SEC 105)"
    start_index = next(index for index, building in enumerate(buildings) if building["name"] == start_building)

    temperature = 1000
    cooling_rate = 0.003
    current_order = list(range(len(buildings)))
    current_order.remove(start_index)
    random.shuffle(current_order)
    current_order.insert(0, start_index)

    best_order = current_order.copy()
    best_distance = total_distance(best_order, buildings)

    while temperature > 1:
        new_order = current_order.copy()

        idx1, idx2 = random.sample(range(1, len(buildings)), 2)
        new_order[idx1], new_order[idx2] = new_order[idx2], new_order[idx1]

        new_distance = total_distance(new_order, buildings)

        if new_distance < best_distance or random.random() < math.exp((best_distance - new_distance) / temperature):
            best_distance = new_distance
            best_order = new_order.copy()

        temperature *= 1 - cooling_rate

    return best_order

optimal_order = simulated_annealing(buildings)
optimal_building_order = [buildings[i]["name"] for i in optimal_order]
print("Optimal Building Order:\n", "\n".join(optimal_building_order))

# Plot the optimal route
x_coords = [building["locations"][1] for building in buildings]  # Longitude
y_coords = [building["locations"][0] for building in buildings]  # Latitude

# Size of the scatter plot
plt.figure(figsize=(15, 15))
plt.scatter(x_coords, y_coords, marker='o', color='pink')

# Plot the points
for building in buildings:
    plt.annotate(building["name"], (building["locations"][1], building["locations"][0]))

route_x_coords = [buildings[i]["locations"][1] for i in optimal_order]
route_y_coords = [buildings[i]["locations"][0] for i in optimal_order]
plt.plot(route_x_coords, route_y_coords, marker='o', linestyle='-', color='blue')

# Axis
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("UH Buildings with Optimal Route: Simulated Annealing")
plt.show()

average_walking_speed = 3.25  # in mph
# Calculate total distance and time taken
sadist_km = total_distance(optimal_order, buildings)
# Convert kilometers to miles
sadist_miles = sadist_km * 0.621371
satime_hours = sadist_miles / average_walking_speed
satime_minutes = satime_hours * 60

print(f"Total Distance: {sadist_km:.4f} kilometers")
print(f"Total Distance: {sadist_miles:.4f} miles")
print(f"Total time: {satime_minutes:.4f} minutes")

import random
import math
random.seed(42)

def euclidean(coord1, coord2):
    return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)

def total_distance(order, building_data):
    distance = 0
    for i in range(len(order) - 1):
        index1, index2 = order[i], order[i + 1]
        coord1 = building_data[index1]["locations"]
        coord2 = building_data[index2]["locations"]
        distance += euclidean(coord1, coord2)
    return distance

def genetic_algorithm(buildings):
    start_building = "Science & Engineering Classroom Building (SEC 105)"
    start_index = next(index for index, building in enumerate(buildings) if building["name"] == start_building)

    population_size = 50
    generations = 100
    mutation_rate = 0.01

    population = []
    for _ in range(population_size):
        order = list(range(len(buildings)))
        order.remove(start_index)
        random.shuffle(order)
        order.insert(0, start_index)
        population.append(order)

    for _ in range(generations):
        fitness_scores = [1 / total_distance(order, buildings) for order in population]
        normalized_fitness = [score / sum(fitness_scores) for score in fitness_scores]

        selected_parents = random.choices(population, weights=normalized_fitness, k=population_size)

        new_population = []
        for _ in range(population_size):
            parent1, parent2 = random.choices(selected_parents, k=2)
            crossover_point = random.randint(0, len(buildings) - 1)
            child = parent1[:crossover_point] + [gene for gene in parent2 if gene not in parent1[:crossover_point]]
            new_population.append(child)

        for i in range(population_size):
            if random.random() < mutation_rate:
                idx1, idx2 = random.sample(range(1, len(buildings)), 2)
                new_population[i][idx1], new_population[i][idx2] = new_population[i][idx2], new_population[i][idx1]

        population = new_population

    best_order = max(population, key=lambda order: 1 / total_distance(order, buildings))

    return best_order

optimal_order = genetic_algorithm(buildings)
optimal_building_order = [buildings[i]["name"] for i in optimal_order]
print("Optimal Building Order:\n", "\n".join(optimal_building_order))

# Plot the optimal route
x_coords = [building["locations"][1] for building in buildings]  # Longitude
y_coords = [building["locations"][0] for building in buildings]  # Latitude

# Size of the scatter plot
plt.figure(figsize=(15, 15))
plt.scatter(x_coords, y_coords, marker='o', color='pink')

# Plot the points
for building in buildings:
    plt.annotate(building["name"], (building["locations"][1], building["locations"][0]))

route_x_coords = [buildings[i]["locations"][1] for i in optimal_order]
route_y_coords = [buildings[i]["locations"][0] for i in optimal_order]
plt.plot(route_x_coords, route_y_coords, marker='o', linestyle='-', color='blue')

# Axis
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("UH Buildings with Optimal Route: Genetic Algorithim")
plt.show()



# Total time and walking distance for all the buildings
# Average walking speed is around 2.5 to 4 mph so I choose 3.25
average_walking_speed = 3.25  # in mph

# Function to calculate Equirectangular distance between two coordinates in kilometers
def equirectangular(coord1, coord2):
    # Radius of the Earth in kilometers
    R = 6371.0

    lat1, lon1 = radians(coord1[0]), radians(coord1[1])
    lat2, lon2 = radians(coord2[0]), radians(coord2[1])

    x = (lon2 - lon1) * cos((lat1 + lat2) / 2)
    y = lat2 - lat1

    distance = R * sqrt(x**2 + y**2)
    return distance

# Calculate total distance
def total_distance(order, building_data):
    distance = 0
    for i in range(len(order) - 1):
        index1, index2 = order[i], order[i + 1]
        coord1 = building_data[index1]["locations"]
        coord2 = building_data[index2]["locations"]
        distance += equirectangular(coord1, coord2)
    return distance

# Calculate total distance and time taken
gadist_km = total_distance(optimal_order, buildings)
# Convert kilometers to miles
gadist_miles = gadist_km * 0.621371
gatime_hours = gadist_miles / average_walking_speed
gatime_minutes = gatime_hours * 60

print(f"Total Distance: {gadist_km:.4f} kilometers")
print(f"Total Distance: {gadist_miles:.4f} miles")
print(f"Total time: {gatime_minutes:.4f} minutes")

#Comparing the distances of all 3 algorithims


optimal_order_nn = nearest_neighbor_algorithm(buildings)
distance_nn = total_distance(optimal_order_nn, buildings)


optimal_order_sa = simulated_annealing(buildings)
distance_sa = total_distance(optimal_order_sa, buildings)


optimal_order_ga = genetic_algorithm(buildings)
distance_ga = total_distance(optimal_order_ga, buildings)


print("Nearest Neighbor Algorithm Total Distance:", distance_nn)
print("Simulated Annealing Total Distance:", distance_sa)
print("Genetic Algorithm Total Distance:", distance_ga)

algorithms = ["Nearest Neighbor", "Simulated Annealing", "Genetic Algorithm"]
distances = [distance_nn, distance_sa, distance_ga]

plt.bar(algorithms, distances, color=["blue", "green", "red"])

plt.xlabel("Algorithm")
plt.ylabel("Distance")
plt.title("Comparison of Distance for Different Algorithms")

plt.show()

"""Nearest neighbor shows less of a distance taken with all 40 buildings so we will pick  nearest neighbors for our custom route optimization for user"""

# Creating distance matrix for the UH buildings
# Prints the buildings in order from the list
def create_distance_matrix(buildings):
    num_buildings = len(buildings)
    distance_matrix = [[0] * num_buildings for _ in range(num_buildings)]

    for i in range(num_buildings):
        for j in range(num_buildings):
            if i != j:
                distance_matrix[i][j] = equirectangular(buildings[i]["locations"], buildings[j]["locations"])

    return distance_matrix

distance_matrix = create_distance_matrix(buildings)
for row in distance_matrix:
    print(row)

#using googlemaps API to have it account for sidewalk on map as requested
import googlemaps
gmaps = googlemaps.Client(key='AIzaSyC2I12LShyobZ6_9yYxXv9uPRTdEBJOuj4')

def get_directions(start_location, end_location):
    directions_result = gmaps.directions(
        start_location,
        end_location,
        mode="walking",
        waypoints=None,
        optimize_waypoints=False,
        alternatives=False,
    )


    polyline = directions_result[0]['overview_polyline']['points']

    decoded_polyline = googlemaps.convert.decode_polyline(polyline)

    return decoded_polyline

import folium
def plot_walking_path(map_object, walking_path_coords):
    coords = [(coord['lat'], coord['lng']) for coord in walking_path_coords]
    folium.PolyLine(coords, color="green", weight=2.5, opacity=1).add_to(map_object)

# Choose your own buildings

# Distance
def calculate_total_distance(order):
    total_distance = 0
    for i in range(len(order) - 1):
        start_building = order[i]
        end_building = order[i + 1]
        start_location = next(building["locations"] for building in buildings if building["name"] == start_building)
        end_location = next(building["locations"] for building in buildings if building["name"] == end_building)
        total_distance += geodesic(start_location, end_location).meters
    return total_distance

#Time
def calculate_total_time(distance, speed):
    # mph to meters per second
    speed_meters_per_second = speed * 0.44704
    time_seconds = distance / speed_meters_per_second
    return time_seconds

# Nearest Neighbor
def nearest_neighbor_algorithm(start_building, rest_of_buildings):
    # Check if the starting building is valid
    valid_buildings = [building["name"] for building in buildings]
    if start_building not in valid_buildings:
        print(f"Invalid starting building name: {start_building}")
        return

    # Check if the rest of the buildings are valid
    for building in rest_of_buildings:
        if building not in valid_buildings:
            print(f"Invalid building name in the list: {building}")
            return

    # Use Nearest Neighbor Algorithm
    remaining_buildings = rest_of_buildings.copy()
    current_building = start_building
    optimal_order = [current_building]

    while len(remaining_buildings) > 0:
        nearest_building = min(remaining_buildings, key=lambda x: geodesic(
            next(b["locations"] for b in buildings if b["name"] == current_building),
            next(b["locations"] for b in buildings if b["name"] == x)
        ).meters)
        optimal_order.append(nearest_building)
        remaining_buildings.remove(nearest_building)
        current_building = nearest_building

    optimal_order.append(start_building)

    # Meters, miles, kilometers distance
    total_distance_meters = calculate_total_distance(optimal_order)
    total_distance_miles = total_distance_meters * 0.000621371
    total_distance_kilometers = total_distance_meters * 0.001

    route_coords = [buildings[valid_buildings.index(building)]["locations"] for building in optimal_order]
    #Creating the map with walking stuff
    global m
    m = folium.Map(location=[29.722, -95.342], zoom_start=17)
    walking_path_coords = []
    for i in range(len(optimal_order) - 1):
      start_building = optimal_order[i]
      end_building = optimal_order[i + 1]

      start_location = next(building["locations"] for building in buildings if building["name"] == start_building)
      end_location = next(building["locations"] for building in buildings if building["name"] == end_building)


      walking_path_coords += get_directions(start_location, end_location)




    plot_walking_path(m, walking_path_coords)
    # Scatter plot with the optimal route
    x_coords = [building["locations"][1] for building in buildings]  # Longitude
    y_coords = [building["locations"][0] for building in buildings]  # Latitude
    plt.figure(figsize=(10, 10))
    plt.scatter(x_coords, y_coords, marker='o', color='pink')
    for building in buildings:
        plt.annotate(building["name"], (building["locations"][1], building["locations"][0]))

    # Plot the optimal route
    route_x_coords = [buildings[valid_buildings.index(building)]["locations"][1] for building in optimal_order]
    route_y_coords = [buildings[valid_buildings.index(building)]["locations"][0] for building in optimal_order]
    plt.plot(route_x_coords, route_y_coords, marker='o', linestyle='-', color='blue')


    # Time to print everything :3
    # Print optimal order, total distance in meters, miles, and kilometers
    print(f"Optimal Order:")
    for building in optimal_order:
        print(building)

    # Calculate total time for walking speeds of 2.5 slow walker and 4 fast walker
    walking_speeds = [2.5, 4]
    for speed in walking_speeds:
        total_time_seconds = calculate_total_time(total_distance_meters, speed)
        total_time_minutes = total_time_seconds / 60
        print(f"\nTotal Time at {speed} mph: {total_time_minutes:.4f} minutes")

    print(f"\nTotal Distance: {total_distance_meters:.4f} meters\n")
    print(f"Total Distance: {total_distance_miles:.4f} miles\n")
    print(f"Total Distance: {total_distance_kilometers:.4f} kilometers\n")

    # Axis
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.title("UH Buildings with Optimal Route")

    # Show the plot
    plt.show()

# User input for starting building and rest of the buildings
start_building = input("Watch out for typos!!\nEnter the starting building: ")
rest_of_buildings = input("Enter the rest of the buildings (separated by a comma and a space):\n").split(', ')

# Run the nearest neighbor algorithm and visualize the scatter plot
nearest_neighbor_algorithm(start_building, rest_of_buildings)

m